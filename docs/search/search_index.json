{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kartoza/docker-geoserver","text":"<p>A simple docker container that runs GeoServer influenced by this docker recipe and maintained by Kartoza </p>"},{"location":"#pre-requisite","title":"Pre-requisite","text":"<ul> <li>Geoserver - Geoserver is a data publishing and sharing tool which implements OGC Protocols</li> <li>Docker - Docker is an open-source project for automating the deployment of applications as portable, self-sufficient containers that can run on the cloud or on-premises.</li> </ul>"},{"location":"#run-geoserver-under-2-min","title":"Run Geoserver under 2 min","text":"<pre><code>VERSION=2.19.0\ndocker pull kartoza/geoserver:$VERSION\ndocker run -p {DESIRED_PORT}:8080  kartoza/geoserver:$VERSION\n</code></pre>"},{"location":"Environment-Variables/","title":"Environment Variables","text":""},{"location":"Environment-Variables/#environment-variables","title":"Environment Variables","text":"<p>A full list of environment variables are specified in the .env file</p>"},{"location":"Environment-Variables/#default-installed-plugins","title":"Default installed  plugins","text":"<p>The image ships with the following stable plugins:</p> <ul> <li>vectortiles-plugin</li> <li>wps-plugin</li> <li>printing-plugin</li> <li>libjpeg-turbo-plugin</li> <li>control-flow-plugin</li> <li>pyramid-plugin</li> <li>gdal-plugin</li> <li>monitor-plugin</li> <li>inspire-plugin</li> <li>csw-plugin</li> </ul> <p>Note: The plugins listed above are omitted from Stable_plugins.txt even though they are considered stable plugins The image activates them on startup.</p> <p>The image provides the necessary plugin zip files which are used when activating the plugins. Not all the plugins will work out of the box because some plugins have extra dependencies which need to be downloaded and installed by users because of their licence terms i.e. db2</p> <p>Some  plugins also need extra configuration parameters i.e. community plugin <code>s3-geotiff-plugin</code></p>"},{"location":"Environment-Variables/#activate-stable-plugins-during-contain-startup","title":"Activate stable plugins during contain startup","text":"<p>The environment variable <code>STABLE_EXTENSIONS</code> can be used to activate plugins listed in Stable_plugins.txt</p> <p>Example</p> <pre><code>ie VERSION=2.22.0\ndocker run -d -p 8600:8080 --name geoserver -e STABLE_EXTENSIONS=charts-plugin,db2-plugin kartoza/geoserver:${VERSION}\n</code></pre> <p>You can pass any comma-separated plugins as defined in the text file <code>stable_plugins.txt</code></p> <p>Note Due to the nature of the plugin ecosystem, there are new plugins that are always being upgraded from community extensions to stable extensions. If the <code>stable_plugins.txt</code> hasn't been updated with the latest changes you can still pass the environment variable with the name of the plugin. The plugin will be downloaded and installed. This might slow down the process of starting GeoServer but will ensure all plugins get activated</p>"},{"location":"Environment-Variables/#activate-community-plugins-during-contain-startup","title":"Activate community plugins during contain startup","text":"<p>The environment variable <code>COMMUNITY_EXTENSIONS</code> can be used to activate plugins listed in community_plugins.txt</p> <p>Example</p> <pre><code>ie VERSION=2.22.0\ndocker run -d -p 8600:8080 --name geoserver -e COMMUNITY_EXTENSIONS=gwc-sqlite-plugin,ogr-datastore-plugin kartoza/geoserver:${VERSION}\n</code></pre> <p>You can also pass the environment variable <code>FORCE_DOWNLOAD_COMMUNITY_EXTENSIONS=true</code> to download the latest community plugins during initialisation of the container.</p> <p>Note: Community plugins are always in flux state. There is no guarantee that plugins will be accessible between each successive build. You can build the extensions following the guidelines from GeoServer develop guidelines</p>"},{"location":"Environment-Variables/#using-sample-data","title":"Using sample data","text":"<p>Geoserver ships with sample data which can be used by users to familiarize them with software. This is not activated by default. You can activate it using the environment variable <code>SAMPLE_DATA=true</code></p> <pre><code>ie VERSION=2.22.0\ndocker run -d -p 8600:8080 --name geoserver -e SAMPLE_DATA=true kartoza/geoserver:${VERSION}\n</code></pre>"},{"location":"Environment-Variables/#enable-disk-quota-storage-in-postgresql-backend","title":"Enable disk quota storage in PostgreSQL backend","text":"<p>GeoServer defaults to using H2 datastore for configuring disk quota. You can alternatively use the PostgreSQL backend as a disk quota store.</p> <p>You will need to run a PostgreSQL DB and link it to a GeoServer instance.</p> <pre><code>docker run -d -p 5432:5432 --name db kartoza/postgis:13.0\ndocker run -d -p 8600:8080 --name geoserver --link db:db -e DB_BACKEND=POSTGRES -e HOST=db -e POSTGRES_PORT=5432 -e POSTGRES_DB=gis -e POSTGRES_USER=docker -e POSTGRES_PASS=docker kartoza/geoserver:2.18.0\n</code></pre> <p>Some additional environment variables to use when activating the disk quota are:</p> <ul> <li>DISK_QUOTA_SIZE - Specifies the size of the disk quota you need to use. Defaults to 20Gb</li> </ul> <p>If you are using the <code>kartoza/docker-postgis</code> image as a database backend you can additionally configure communication between the containers to use SSL</p> <p>If you want to test it locally with docker-compose postgres db you need to specify these env variables:</p> <pre><code>    - DB_BACKEND=POSTGRES               \n    - HOST=db                          \n    - POSTGRES_PORT=5432                \n    - POSTGRES_DB=gwc                   \n    - POSTGRES_USER=${POSTGRES_USER}    \n    - POSTGRES_PASS=${POSTGRES_PASS}    \n    - SSL_MODE=allow                    \n    - POSTGRES_SCHEMA=public           \n    - DISK_QUOTA_SIZE=5\n</code></pre> <p>NOTE: </p> <pre><code>HOST should be your local container name for db\nPOSTGRES_SCHEMA works only with 'public' right now\n</code></pre>"},{"location":"Environment-Variables/#using-ssl-and-default-postgresql-ssl-certificates","title":"Using SSL and Default PostgreSQL ssl certificates","text":"<p>When the environment variable <code>FORCE_SSL=TRUE</code> is set for the database container you will need to set <code>SSL_MODE=allow</code> in the GeoServer container.</p>"},{"location":"Environment-Variables/#using-ssl-certificates-signed-by-a-certificate-authority","title":"Using SSL certificates signed by a certificate authority","text":"<p>When the environment variable <code>FORCE_SSL=TRUE</code> is set for the database container you will need to set <code>SSL_MODE</code> to either <code>verify-full</code> or <code>verify-ca</code> for the GeoServer container. You will also need to mount the ssl certificates you have done in the DB.</p> <p>In the GeoServer container, the certificates need to be mounted to the folder specified by the certificate directory ${CERT_DIR}</p> <pre><code>SSL_CERT_FILE=/etc/certs/fullchain.pem\nSSL_KEY_FILE=/etc/certs/privkey.pem\nSSL_CA_FILE=/etc/certs/root.crt\n</code></pre>"},{"location":"Environment-Variables/#activating-jndi-postgresql-connector","title":"Activating JNDI PostgreSQL connector","text":"<p>When defining vector stores you can use the JNDI pooling. To set this up you will need to activate the following  environment variable <code>POSTGRES_JNDI=TRUE</code>. By default, the environment the variable is set to <code>FALSE</code> Additionally, you will need to define parameters to connect to an existing PostgreSQL database</p> <pre><code>POSTGRES_JNDI=TRUE\nHOST=${POSTGRES_HOSTNAME}\nPOSTGRES_DB=${POSTGRES_DB}\nPOSTGRES_USER=${POSTGRES_USER}\nPOSTGRES_PASS=${POSTGRES_PASS}\n</code></pre> <p>If you are using the kartoza/postgis image with the env variable <code>FORCE_SSL=TRUE</code> you will also need to set the environment variable <code>SSL_MODE</code> to correspond to value mentioned in kartoza/postgis ssl</p> <p>When defining the parameters for the store in GeoServer you will need to set <code>jndiReferenceName=java:comp/env/jdbc/postgres</code></p>"},{"location":"Environment-Variables/#running-under-ssl","title":"Running under SSL","text":"<p>You can use the environment variables to specify whether you want to run the GeoServer under SSL. Credits to letsencrpt for providing the solution to run under SSL.</p> <p>If you set the environment variable <code>SSL=true</code> but do not provide the pem files (fullchain.pem and privkey.pem) the container will generate a self-signed SSL certificates.</p> <pre><code>ie VERSION=2.22.0\ndocker run -it --name geoserver  -e PKCS12_PASSWORD=geoserver -e JKS_KEY_PASSWORD=geoserver -e JKS_STORE_PASSWORD=geoserver -e SSL=true -p 8443:8443 -p 8600:8080 kartoza/geoserver:${VERSION}\n</code></pre> <p>If you already have your perm files (fullchain.pem and privkey.pem) you can mount the directory containing your keys as:</p> <pre><code>ie VERSION=2.22.0\ndocker run -it --name geo -v /etc/certs:/etc/certs  -e PKCS12_PASSWORD=geoserver -e JKS_KEY_PASSWORD=geoserver -e JKS_STORE_PASSWORD=geoserver -e SSL=true -p 8443:8443 -p 8600:8080 kartoza/geoserver:${VERSION}\n\n</code></pre> <p>You can also use a PFX file with this image. Rename your PFX file as certificate.pfx and then mount the folder containing your pfx file. This will be converted to perm files.</p> <p>Note When using PFX files make sure that the ALIAS_KEY you specify as an environment variable matches the ALIAS_KEY that was used when generating your PFX key.</p> <p>A full list of SSL variables is provided here</p> <ul> <li>HTTP_PORT</li> <li>HTTP_PROXY_NAME</li> <li>HTTP_PROXY_PORT</li> <li>HTTP_REDIRECT_PORT</li> <li>HTTP_CONNECTION_TIMEOUT</li> <li>HTTP_COMPRESSION</li> <li>HTTP_SCHEME</li> <li>HTTP_MAX_HEADER_SIZE</li> <li>HTTP_RELAX_CHARS</li> <li>HTTP_RELAX_QUERY</li> <li>HTTPS_SCHEME</li> <li>HTTPS_PORT</li> <li>HTTPS_MAX_THREADS</li> <li>HTTPS_CLIENT_AUTH</li> <li>HTTPS_PROXY_NAME</li> <li>HTTPS_PROXY_PORT</li> <li>HTTPS_COMPRESSION</li> <li>HTTPS_MAX_HEADER_SIZE</li> <li>JKS_FILE</li> <li>JKS_KEY_PASSWORD</li> <li>KEY_ALIAS</li> <li>JKS_STORE_PASSWORD</li> <li>P12_FILE</li> </ul>"},{"location":"Environment-Variables/#proxy-base-url","title":"Proxy Base URL","text":"<p>For the server to report a full proxy base url, you need to pass the following env variable i.e.</p> <pre><code>HTTP_PROXY_NAME\nHTTP_PROXY_PORT\n</code></pre> <p>If you are running GeoServer under SSL with reverse proxy i.e nginx you will need to set the following env variables</p> <p>Example below:</p> <pre><code>HTTP_PROXY_NAME=foo.org\nHTTP_SCHEME=https\n</code></pre> <p>This will prevent the login form from sending insecure http post request as experienced in login issue</p> <p>For SSL based connections the env variables are:</p> <pre><code>HTTPS_PROXY_NAME\nHTTPS_PROXY_PORT\nHTTPS_SCHEME\n</code></pre>"},{"location":"Environment-Variables/#removing-tomcat-extras","title":"Removing Tomcat extras","text":"<p>To include Tomcat extras including docs, examples, and the manager webapp, set the <code>TOMCAT_EXTRAS</code> environment variable to <code>true</code>:</p> <p>Note: If <code>TOMCAT_EXTRAS</code> is set to true then you should configure  <code>TOMCAT_PASSWORD</code> to use a strong password otherwise the default one is set up.</p> <pre><code>ie VERSION=2.22.0\ndocker run -it --name geoserver  -e TOMCAT_EXTRAS=true -p 8600:8080 kartoza/geoserver:${VERSION}\n</code></pre> <p>Note: If <code>TOMCAT_EXTRAS</code> is set to false, requests to the root webapp (\"/\") will return HTTP status code 404.  To issue a redirect to the GeoServer webapp (\"/geoserver/web\") set <code>ROOT_WEBAPP_REDIRECT=true</code></p>"},{"location":"Environment-Variables/#upgrading-image-to-use-a-specific-version","title":"Upgrading image to use a specific version","text":"<p>During initialization, the image will run a script that updates the passwords. This is recommended to change passwords the first time that GeoServer runs. If you are migrating your GeoServer instance, from one a lower version to a higher one you will need to set the environment variable <code>EXISTING_DATA_DIR</code>; unset it to run the initialization script.</p> <p>The environment variable will ensure that the password initialization is skipped during the startup procedure.</p> <p>If you set the env variable <code>EXISTING_DATA_DIR</code> to any value i.e <code>EXISTING_DATA_DIR=foo</code> or <code>EXISTING_DATA_DIR=false</code> it will result in password update being skipped. So if you need to have the password being updated do not include the env variable in your configuration (this is the default configuration).</p>"},{"location":"Environment-Variables/#installing-extra-fonts","title":"Installing extra fonts","text":"<p>If you have downloaded extra fonts you can mount the folder to the path <code>/opt/fonts</code>. This will ensure that all the .ttf files are copied to the correct path during initialisation.</p> <pre><code>ie VERSION=2.22.0\ndocker run -v fonts:/opt/fonts -p 8080:8080 -t kartoza/geoserver:${VERSION}\n</code></pre>"},{"location":"Environment-Variables/#other-environment-variables-supported","title":"Other Environment variables supported","text":"<p>You can also use the following environment variables to pass arguments to GeoServer:</p> <ul> <li><code>GEOSERVER_DATA_DIR=&lt;PATH&gt;</code></li> <li><code>ENABLE_JSONP=&lt;true or false&gt;</code></li> <li><code>MAX_FILTER_RULES=&lt;Any integer&gt;</code></li> <li><code>OPTIMIZE_LINE_WIDTH=&lt;false or true&gt;</code></li> <li><code>FOOTPRINTS_DATA_DIR=&lt;PATH&gt;</code></li> <li><code>GEOWEBCACHE_CACHE_DIR=&lt;PATH&gt;</code></li> <li><code>GEOSERVER_ADMIN_PASSWORD=&lt;password&gt;</code></li> <li><code>GEOSERVER_ADMIN_USER=&lt;username&gt;</code></li> <li><code>GEOSERVER_FILEBROWSER_HIDEFS=&lt;false or true&gt;</code></li> <li><code>XFRAME_OPTIONS=\"true\"</code> - In order to prevent clickjacking attacks GeoServer defaults to setting the X-Frame-Options HTTP header to SAMEORIGIN. Controls whether the X-Frame-Options filter should be set at all. Default is true</li> <li> <p>Tomcat properties:</p> </li> <li> <p>You can change the variables based on geoserver container considerations.    These arguments operate on the <code>-Xms</code> and <code>-Xmx</code> options of the Java Virtual Machine</p> </li> <li><code>INITIAL_MEMORY=&lt;size&gt;</code> : Initial Memory that Java can allocate, default <code>2G</code></li> <li><code>MAXIMUM_MEMORY=&lt;size&gt;</code> : Maximum Memory that Java can allocate, default <code>4G</code></li> <li><code>ACTIVATE_ALL_COMMUNITY_EXTENSIONS</code> : Activates all downloaded community plugins</li> <li><code>ACTIVATE_ALL_STABLE_EXTENSIONS</code> : Activates all stable plugins previously downloaded</li> </ul> <p>Note: Before using <code>ACTIVATE_ALL_STABLE_EXTENSIONS</code> and <code>ACTIVATE_ALL_COMMUNITY_EXTENSIONS</code> ensure that all prerequisites for those plugins are matched otherwise the container will not start and errors will result</p>"},{"location":"Environment-Variables/#control-flow-properties","title":"Control flow properties","text":"<p>The control flow module manages requests in GeoServer. Instructions on what each parameter mean can be read from documentation.</p> <ul> <li> <p>Example default values for the environment variables</p> <ul> <li><code>REQUEST_TIMEOUT=60</code></li> <li><code>PARALLEL_REQUEST=100</code></li> <li><code>GETMAP=10</code></li> <li><code>REQUEST_EXCEL=4</code></li> <li><code>SINGLE_USER=6</code></li> <li><code>GWC_REQUEST=16</code></li> <li><code>WPS_REQUEST=1000/d;30s</code></li> </ul> </li> </ul> <p>Note: You should customise these variables based on the resources available with your GeoServer</p>"},{"location":"Environment-Variables/#changing-geoserver-password-and-username","title":"Changing GeoServer password and username","text":"<p>You can pass the environment variables to change it on runtime.</p> <pre><code>GEOSERVER_ADMIN_PASSWORD\nGEOSERVER_ADMIN_USER\n</code></pre> <p>The username and password are reinitialized each time the container starts. If you do not pass the env variables <code>GEOSERVER_ADMIN_PASSWORD</code> the container will generate a new password which is visible in the startup logs.</p> <p>Note: When upgrading the <code>GEOSERVER_ADMIN_PASSWORD</code> and <code>GEOSERVER_ADMIN_USER</code> you will need to mount the volume <code>settings:/settings</code> so that the lock-files generated by the <code>update_password.sh</code> are persistent during initialization. See the example in docker-compose-build</p> <pre><code>docker run --name \"geoserver\" -e GEOSERVER_ADMIN_USER=kartoza  -e GEOSERVER_ADMIN_PASSWORD=myawesomegeoserver -p 8080:8080 -d -t kartoza/geoserver\n</code></pre> <p>Note: The docker-compose recipe uses the password <code>myawesomegeoserver</code>. It is highly recommended not to run the container in production using these values.</p>"},{"location":"Environment-Variables/#docker-secrets","title":"Docker secrets","text":"<p>To avoid passing sensitive information in environment variables, <code>_FILE</code> can be appended to some variables to read from files present in the container. This is particularly useful in conjunction with Docker secrets, as passwords can be loaded from <code>/run/secrets/&lt;secret_name&gt;</code> e.g.:</p> <ul> <li>-e GEOSERVER_ADMIN_PASSWORD_FILE=/run/secrets/ <p>For more information see https://docs.docker.com/engine/swarm/secrets/.</p> <p>Currently, the following environment variables</p> <pre><code> GEOSERVER_ADMIN_USER\n GEOSERVER_ADMIN_PASSWORD\n S3_USERNAME\n S3_PASSWORD\n TOMCAT_USER\n TOMCAT_PASSWORD\n PKCS12_PASSWORD\n JKS_KEY_PASSWORD\n JKS_STORE_PASSWORD\n</code></pre> <p>are supported.</p>"},{"location":"Getting-the-image/","title":"Getting the image","text":"<p>There are various ways to get the image onto your system:</p> <ul> <li>Pulling from Dockerhub</li> <li>Local build using docker-compose</li> </ul>"},{"location":"Getting-the-image/#pulling-from-dockerhub","title":"Pulling from Dockerhub","text":"<p>The preferred way (but using most bandwidth for the initial image) is to get our docker trusted build like this:</p> <pre><code>VERSION=2.22.0\ndocker pull kartoza/geoserver:$VERSION\n</code></pre>"},{"location":"Getting-the-image/#building-the-image","title":"Building the image","text":""},{"location":"Getting-the-image/#local-build-using-repository-checkout","title":"Local build using repository checkout","text":"<p>To build yourself with a local checkout using the docker-compose.build.yaml:</p> <ol> <li>Clone the GitHub repository:</li> </ol> <pre><code>   git clone https://github.com/kartoza/docker-geoserver\n</code></pre> <ol> <li>Edit the .env to change the build arguments:</li> </ol> <pre><code>   IMAGE_VERSION=[dockerhub tomcat](https://hub.docker.com/_/tomcat/)\n   JAVA_HOME= java home path corresponding to the tomcat version\n   WAR_URL= Default URL to fetch GeoServer war or zip file\n   STABLE_PLUGIN_URL= URL to fetch GeoServer plugins\n   DOWNLOAD_ALL_STABLE_EXTENSIONS= Specifies whether to download all stable plugins or a single one\n   DOWNLOAD_ALL_COMMUNITY_EXTENSIONS=Specifies whether to download all community plugins or a single one\n   GEOSERVER_UID=Specifies the uid to use for the user used to run GeoServer in the container\n   GEOSERVER_GID=Specifies the gid to use for the group used to run GeoServer in the container\n</code></pre> <ol> <li>Build the container and spin up the services</li> </ol> <pre><code>   cd docker-geoserver\n   docker-compose -f docker-compose-build.yml up -d --build\n</code></pre>"},{"location":"Getting-the-image/#building-with-a-specific-version-of-tomcat","title":"Building with a specific version of  Tomcat","text":"<p>To build using a specific tagged release for tomcat image set the <code>IMAGE_VERSION</code> build-arg to <code>8-jre8</code>: See the dockerhub tomcat to choose which tag you need to build against.</p> <pre><code>ie VERSION=2.22.0\ndocker build --build-arg IMAGE_VERSION=8-jre8 --build-arg GS_VERSION=2.22.0 -t kartoza/geoserver:${VERSION} .\n</code></pre> <p>For some recent builds it is necessary to set the JAVA_PATH as well (e.g. Apache Tomcat/9.0.36)</p> <pre><code>docker build --build-arg IMAGE_VERSION=9-jdk11-openjdk-slim --build-arg JAVA_HOME=/usr/local/openjdk-11/bin/java --build-arg GS_VERSION=2.22.0 -t kartoza/geoserver:2.22.0 .\n</code></pre> <p>Note: Please check the GeoServer documentation  to see which tomcat versions are supported.</p>"},{"location":"Getting-the-image/#building-on-windows","title":"Building on Windows","text":"<p>These instructions detail the recommended process for reliably building this on Windows.</p> <p>Prerequisites - You will need to have this software preinstalled on the system being used to build the Geoserver image:</p> <ul> <li>Docker Desktop with WSL2</li> <li>Java JDK</li> <li>Conda</li> <li>GDAL (Install with Conda)</li> </ul> <p>Add the conda-forge channel to your conda installation:</p> <pre><code>conda config --add channels conda-forge\n</code></pre> <p>Now create a new conda environment with GDAL, installed from conda. Ensure that this environment is active when running the docker build, e.g.</p> <pre><code>conda create -n geoserver-build -c conda-forge python gdal\nconda activate geoserver-build\n</code></pre> <p>Modify the <code>.env</code> with the appropriate environment variables. It is recommended that shortpaths (without whitespace)  are used with forward slashes to prevent errors. You can get the current java command short path with powershell:</p> <pre><code>(New-Object -ComObject Scripting.FileSystemObject).GetFile((get-command java).Source).ShortPath\n</code></pre> <p>Running the above command should yield a path similar to <code>C:/PROGRA~1/Java/JDK-15~1.2/bin/java.exe</code>, which can be  assigned to <code>JAVA_HOME</code> in the environment confoguration file.</p> <p>Then run the docker build commands. If you encounter issues, you may want to ensure that you try to build the image  without the cache and then run docker up separately:</p> <pre><code>docker-compose -f docker-compose-build.yml build --force-rm --no-cache\ndocker-compose -f docker-compose-build.yml up -d\n</code></pre>"},{"location":"Kubernetes/","title":"Kubernetes","text":""},{"location":"Kubernetes/#kubernetes-helm-charts","title":"Kubernetes (Helm Charts)","text":"<p>You can run the image in Kubernetes following the recipe</p>"},{"location":"Kubernetes/#contributing-to-the-image","title":"Contributing to the image","text":"<p>We welcome users who want to contribute  enriching this service. We follow the git principles and all pull requests should be against the develop branch so that we can test them and when we are happy we push them to the master branch.</p>"},{"location":"Kubernetes/#upgrading-geoserver-versions","title":"Upgrading GeoServer Versions","text":"<p>GeoServer releases and bug fixes are done frequently. We provide a helper script <code>upgrade_geoserver_version.sh</code> which can be run to update the respective files which mention GeoServer version. To run this you need to run</p> <pre><code>/bin/bash upgrade_geoserver_version.sh ${GS_VERSION} ${GS_NEW_VERSION}\n</code></pre> <p>Note: The script will also push this changes to the current repo, and it is up to the individual running the script to push the changes to his specific branch of choice and then complete the pull request</p>"},{"location":"Mounting-Configs/","title":"Mounting Configs","text":""},{"location":"Mounting-Configs/#mounting-configs","title":"Mounting Configs","text":"<p>You can mount the config file to the path <code>/settings</code>. These configs will be used in favour of the defaults that are available from the Build data directory</p> <p>The configs that can be mounted are</p> <ul> <li>cluster.properties</li> <li>controlflow.properties</li> <li>embedded-broker.properties</li> <li>geowebcache-diskquota-jdbc.xml</li> <li>s3.properties</li> <li>tomcat-users.xml</li> <li>web.xml - for tomcat cors</li> <li>epsg.properties - for custom GeoServer EPSG values</li> <li>server.xml - for tomcat configurations</li> <li>broker.xml</li> <li>users.xml - for Geoserver users.</li> <li>roles.xml - To define roles users should have in GeoServer</li> </ul> <p>Example</p> <pre><code> docker run --name \"geoserver\" -e GEOSERVER_ADMIN_USER=kartoza  -v /data/controlflow.properties:/settings/controlflow.properties -p 8080:8080 -d -t kartoza/geoserver\n</code></pre> <p>Note: The files <code>users.xml</code> and <code>roles.xml</code> should be mounted together to prevent errors during container start. Mounting these two files will overwrite <code>GEOSERVER_ADMIN_PASSWORD</code> and <code>GEOSERVER_ADMIN_USER</code></p>"},{"location":"Mounting-Configs/#cors-support","title":"CORS Support","text":"<p>The image ships with CORS support. If you however need to modify the web.xml you can mount <code>web.xml</code> to <code>/settings/</code> directory.</p>"},{"location":"Running-the-Image/","title":"Running the Image","text":""},{"location":"Running-the-Image/#running-the-image","title":"Running the Image","text":""},{"location":"Running-the-Image/#run-automated-using-docker-compose","title":"Run (automated using docker-compose)","text":"<p>Note: You probably want to use docker-compose for running as it will provide a repeatable orchestrated deployment system.</p> <p>We provide a sample <code>docker-compose.yml</code> file that illustrates how you can establish a GeoServer + PostGIS.</p> <p>If you are interested in the backups , add a section in the <code>docker-compose.yml</code> following instructions from docker-pg-backup.</p> <p>If you start the stack using the compose file make sure you log in into GeoServer using username:<code>admin</code> and password:<code>myawesomegeoserver</code>.</p> <p>Note The username and password are specified in the <code>.env</code> file. It is recommended to change them into something more secure otherwise a strong password is generated.</p> <p>Please read the <code>docker-compose</code> documentation for details on usage and syntax of <code>docker-compose</code> - it is  not covered here.</p> <p>Once all the services start, test by visiting the GeoServer landing page in your browser: http://localhost:8600/geoserver.</p> <p>To run in the background rather, press <code>ctrl-c</code> to stop the containers and run again in the background:</p> <pre><code>docker-compose up -d\n</code></pre> <p>Note: The <code>docker-compose.yml</code> uses host-based volumes so when you remove the containers, all data will be kept. Using host-based volumes ensures that your data persists  between invocations of the compose file. If you need to delete the container data you need to run <code>docker-compose down -v</code>.</p>"},{"location":"Running-the-Image/#reverse-proxy-using-nginx","title":"Reverse Proxy using NGINX","text":"<p>You can also put Nginx in front of GeoServer to receive the http request and translate it to uwsgi.</p> <p>A sample <code>docker-compose-nginx.yml</code> is provided for running GeoServer and Nginx</p> <pre><code>docker-compose -f docker-compose-nginx.yml  up -d\n</code></pre> <p>Once the services are running GeoServer will be available from</p> <p>http://localhost/geoserver/web/</p>"},{"location":"Running-the-Image/#additional-notes-for-macos-m1-chip","title":"Additional Notes for MacOS M1 Chip","text":"<p>To run the docker image with MacOS M1 Chip, the image needs to be built locally.</p> <ul> <li>JDK version of \u201c9-jdk17-openjdk-slim-buster \u201c can work with M1 Chip as it is instructed on \"Local build using  repository checkout\" section, the parameters below needs to be changed in .env file and Dockerfile</li> </ul> <pre><code>IMAGE_VERSION=9-jdk17-openjdk-slim-buster\nJAVA_HOME=/usr/local/openjdk-17\n</code></pre> <ul> <li>The change above also requires the removal of some command-line options in  entrypoint.sh file.  (Since they generate <code>Unrecognized VM option 'CMSClassUnloadingEnabled'</code> error and these options are related to  JDK10 and lower)</li> </ul> <pre><code>-XX:+CMSClassUnloadingEnabled\n-XX:+UseG1GC\n</code></pre> <p>After these changes, the image can be built as instructed.</p> <p>To run the just-built local image with your docker-compose file, the platform option in the docker-compose file  needs to be specified as <code>linux/arm64/v8</code>. Otherwise, it will try to pull the docker image from the docker hub  instead of using the local image.</p>"},{"location":"Running-the-Image/#reverse-proxy-using-nginx_1","title":"Reverse Proxy using NGINX","text":"<p>You can also put nginx in front of geoserver to receive http request and translate it to uwsgi.</p> <p>A sample <code>docker-compose-nginx.yml</code> is provided for running geoserver and nginx</p> <pre><code>docker-compose -f docker-compose-nginx.yml  up -d\n</code></pre> <p>Once the services are running GeoServer will be available from</p> <p>http://localhost/geoserver/web/</p>"},{"location":"Support-and-credits/","title":"Support and credits","text":""},{"location":"Support-and-credits/#support","title":"Support","text":"<p>When reporting issue especially related to installed plugins (community and stable) please refer to the GeoServer Issue page to see if there are no issues reported there. We rely on the GeoServer community to resolve upstream issues. For urgent upstream problems you will need to get paid support the developers in GeoServer. </p> <p>Other platforms where users can ask questions and get assistance are listed below: * Stack Exchange * GeoServer Mailing lists * GeoServer Commercial Support</p> <p>If you require more substantial assistance from kartoza  (because our work and interaction on  docker-geoserver is pro bono), please consider taking out a Support Level Agreeement</p>"},{"location":"Support-and-credits/#credits","title":"Credits","text":"<ul> <li>Tim Sutton (tim@kartoza.com)</li> <li>Shane St Clair (shane@axiomdatascience.com)</li> <li>Alex Leith (alexgleith@gmail.com)</li> <li>Admire Nyakudya (admire@kartoza.com)</li> <li>Gavin Fleming (gavin@kartoza.com)</li> </ul>"}]}